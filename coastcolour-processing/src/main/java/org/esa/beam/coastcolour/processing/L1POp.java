package org.esa.beam.coastcolour.processing;

import org.esa.beam.framework.datamodel.Band;
import org.esa.beam.framework.datamodel.FlagCoding;
import org.esa.beam.framework.datamodel.Product;
import org.esa.beam.framework.datamodel.ProductNodeGroup;
import org.esa.beam.framework.gpf.GPF;
import org.esa.beam.framework.gpf.Operator;
import org.esa.beam.framework.gpf.OperatorException;
import org.esa.beam.framework.gpf.OperatorSpi;
import org.esa.beam.framework.gpf.annotations.OperatorMetadata;
import org.esa.beam.framework.gpf.annotations.Parameter;
import org.esa.beam.framework.gpf.annotations.SourceProduct;
import org.esa.beam.util.ProductUtils;

import java.util.HashMap;
import java.util.Map;

@OperatorMetadata(alias = "CoastColour.L1P")
public class L1POp extends Operator {

    static final String IDEPIX_OPERATOR_ALIAS = "idepix.ComputeChain";
    static final String RADIOMETRY_OPERATOR_ALIAS = "Meris.CorrectRadiometry";
    static final String CLOUD_FLAG_BAND_NAME = "cloud_classif_flags";
    private static final String L1P_FLAG_BAND_NAME = "l1p_flags";
    @SourceProduct(alias = "l1b", description = "MERIS L1b (N1) product")
    private Product source;
    @Parameter(defaultValue = "true")
    private boolean doSmile;

    @Override
    public void initialize() throws OperatorException {

        final Map<String, Object> rcParams = new HashMap<String, Object>();
        rcParams.put("doCalibration", true);
        rcParams.put("doSmile", doSmile);
        rcParams.put("doEqualization", true);
        rcParams.put("doRadToRefl", false);
        final Product rcProduct = GPF.createProduct(RADIOMETRY_OPERATOR_ALIAS, rcParams, source);

        final Product idepixProduct = GPF.createProduct(IDEPIX_OPERATOR_ALIAS, GPF.NO_PARAMS, rcProduct);

        final Band cloud_classif_flags = ProductUtils.copyBand(CLOUD_FLAG_BAND_NAME, idepixProduct, rcProduct);
        if (cloud_classif_flags == null) {
            String msg = String.format("Flag band '%1$s' is not generated by operator '%2$s' ",
                                       CLOUD_FLAG_BAND_NAME, IDEPIX_OPERATOR_ALIAS);
            throw new OperatorException(msg);
        }
        cloud_classif_flags.setSourceImage(idepixProduct.getBand(CLOUD_FLAG_BAND_NAME).getSourceImage());
        cloud_classif_flags.setName(L1P_FLAG_BAND_NAME);

        final FlagCoding flagCoding = idepixProduct.getBand(CLOUD_FLAG_BAND_NAME).getFlagCoding();
        if (flagCoding == null) {
            String msg = String.format("Flag band '%1$s' has no associated flag-coding.", CLOUD_FLAG_BAND_NAME);
            throw new OperatorException(msg);
        }

        ProductUtils.copyFlagCoding(flagCoding, rcProduct);
        final ProductNodeGroup<FlagCoding> rcFlagCodingGroup = rcProduct.getFlagCodingGroup();
        final FlagCoding cloudFlagCoding = rcFlagCodingGroup.get(CLOUD_FLAG_BAND_NAME);
        cloud_classif_flags.setSampleCoding(cloudFlagCoding);
        cloudFlagCoding.setName(L1P_FLAG_BAND_NAME);

        final String productType = rcProduct.getProductType();
        rcProduct.setProductType(productType.replaceFirst("_1P", "L1P"));
        setTargetProduct(rcProduct);
    }

    public static class Spi extends OperatorSpi {

        public Spi() {
            super(L1POp.class);
        }
    }
}
