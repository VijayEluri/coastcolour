package org.esa.beam.coastcolour.processing;

import org.esa.beam.framework.datamodel.Band;
import org.esa.beam.framework.datamodel.FlagCoding;
import org.esa.beam.framework.datamodel.Product;
import org.esa.beam.framework.datamodel.ProductNodeGroup;
import org.esa.beam.framework.gpf.GPF;
import org.esa.beam.framework.gpf.Operator;
import org.esa.beam.framework.gpf.OperatorException;
import org.esa.beam.framework.gpf.OperatorSpi;
import org.esa.beam.framework.gpf.annotations.OperatorMetadata;
import org.esa.beam.framework.gpf.annotations.Parameter;
import org.esa.beam.framework.gpf.annotations.SourceProduct;
import org.esa.beam.idepix.operators.CloudScreeningSelector;
import org.esa.beam.util.ProductUtils;

import java.util.HashMap;
import java.util.Map;

@OperatorMetadata(alias = "CoastColour.L1P")
public class L1POp extends Operator {

    static final String IDEPIX_OPERATOR_ALIAS = "idepix.ComputeChain";
    static final String RADIOMETRY_OPERATOR_ALIAS = "Meris.CorrectRadiometry";
    static final String CLOUD_FLAG_BAND_NAME = "cloud_classif_flags";
    private static final String L1P_FLAG_BAND_NAME = "l1p_flags";
    @SourceProduct(alias = "l1b", description = "MERIS L1b (N1) product")
    private Product sourceProduct;

    @Parameter(defaultValue = "true")
    private boolean doSmile;

    @Parameter(defaultValue = "true")
    private boolean useIdepix;

    @Parameter(defaultValue = "GlobAlbedo", valueSet = {"GlobAlbedo", "QWG",  "CoastColour"})
    private CloudScreeningSelector algorithm;

    @Override
    public void initialize() throws OperatorException {

        final Map<String, Object> rcParams = new HashMap<String, Object>();
        rcParams.put("doCalibration", true);
        rcParams.put("doSmile", doSmile);
        rcParams.put("doEqualization", true);
        rcParams.put("doRadToRefl", false);
        final Product rcProduct = GPF.createProduct(RADIOMETRY_OPERATOR_ALIAS, rcParams, sourceProduct);

        if (useIdepix) {
            HashMap<String, Object> idepixParams = new HashMap<String, Object>();
            idepixParams.put("algorithm", algorithm);
            final Product idepixProduct = GPF.createProduct(IDEPIX_OPERATOR_ALIAS, idepixParams, rcProduct);

            final Band cloudClassifFlags = ProductUtils.copyBand(CLOUD_FLAG_BAND_NAME, idepixProduct, rcProduct);
            if (cloudClassifFlags == null) {
                String msg = String.format("Flag band '%1$s' is not generated by operator '%2$s' ",
                                           CLOUD_FLAG_BAND_NAME, IDEPIX_OPERATOR_ALIAS);
                throw new OperatorException(msg);
            }
            cloudClassifFlags.setSourceImage(idepixProduct.getBand(CLOUD_FLAG_BAND_NAME).getSourceImage());
            cloudClassifFlags.setName(L1P_FLAG_BAND_NAME);

            final FlagCoding flagCoding = idepixProduct.getBand(CLOUD_FLAG_BAND_NAME).getFlagCoding();
            if (flagCoding == null) {
                String msg = String.format("Flag band '%1$s' has no associated flag-coding.", CLOUD_FLAG_BAND_NAME);
                throw new OperatorException(msg);
            }

            ProductUtils.copyFlagCoding(flagCoding, rcProduct);
            final ProductNodeGroup<FlagCoding> rcFlagCodingGroup = rcProduct.getFlagCodingGroup();
            final FlagCoding cloudFlagCoding = rcFlagCodingGroup.get(CLOUD_FLAG_BAND_NAME);
            cloudClassifFlags.setSampleCoding(cloudFlagCoding);
            cloudFlagCoding.setName(L1P_FLAG_BAND_NAME);
        }

        final String productType = rcProduct.getProductType();
        rcProduct.setProductType(productType.replaceFirst("_1P", "L1P"));
        setTargetProduct(rcProduct);
    }

    public static class Spi extends OperatorSpi {

        public Spi() {
            super(L1POp.class);
        }
    }
}
